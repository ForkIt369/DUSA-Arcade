<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>DUSA Pong | DUSA Arcade</title>
    <link rel="stylesheet" href="../../shared/styles/embed.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #0D1117;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(30, 58, 138, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(59, 130, 246, 0.1) 0%, transparent 50%);
        }
        
        .game-container {
            background-color: #161B22;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            position: relative;
        }
        
        h1 {
            font-size: 2.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #1E3A8A, #3B82F6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0 1rem;
        }
        
        .player-info, .ai-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .avatar-container {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #1E3A8A;
            box-shadow: 0 0 10px rgba(30, 58, 138, 0.5);
            transition: all 0.3s ease;
        }
        
        .avatar-container.player-color {
            border-color: #3B82F6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
        }
        
        .avatar-container.ai-color {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
        }
        
        .avatar-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .score {
            font-size: 2rem;
            font-weight: 600;
        }
        
        .player-score {
            color: #3B82F6;
        }
        
        .ai-score {
            color: #4CAF50;
        }
        
        .match-score {
            font-size: 0.9rem;
            color: #8B92A3;
            margin-top: 0.5rem;
        }
        
        .match-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .match-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: #FFD700;
        }
        
        .first-to {
            font-size: 0.9rem;
            color: #8B92A3;
        }
        
        .player-info, .ai-info {
            flex-direction: column;
        }
        
        canvas {
            border: 2px solid #1E3A8A;
            border-radius: 8px;
            background-color: #0D1117;
            display: block;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(30, 58, 138, 0.3);
            transition: box-shadow 0.3s ease;
        }
        
        .controls {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            background-color: #1E3A8A;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button:not(:disabled):hover {
            background-color: #3B82F6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
        }
        
        .game-select {
            background-color: #1E3A8A;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'DM Sans', sans-serif;
        }
        
        .game-select:hover {
            background-color: #3B82F6;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.4);
        }
        
        .difficulty-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.9rem;
            color: #8B92A3;
        }
        
        .flame-trail {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.8;
            filter: blur(2px);
        }
        
        .instructions {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #8B92A3;
        }
        
        .mobile-controls {
            display: none;
            margin-top: 1rem;
            gap: 1rem;
            justify-content: center;
        }
        
        .mobile-controls button {
            width: 80px;
            height: 80px;
            font-size: 2rem;
            border-radius: 50%;
            background-color: #2D333B;
            border: 2px solid #1E3A8A;
        }
        
        .score-celebration {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            display: none;
            z-index: 1000;
            animation: scorePopup 1s ease-out forwards;
            pointer-events: none;
        }
        
        .score-celebration img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .score-celebration.player-celebration {
            border: 4px solid #3B82F6;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.8);
        }
        
        .score-celebration.ai-celebration {
            border: 4px solid #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.8);
        }
        
        @keyframes scorePopup {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }
        
        .game-over-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #161B22;
            border: 3px solid #1E3A8A;
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            display: none;
            z-index: 2000;
            box-shadow: 0 0 50px rgba(30, 58, 138, 0.8);
        }
        
        .game-over-modal h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #FFD700;
        }
        
        .winner-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 1rem auto;
            border: 3px solid #FFD700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .winner-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .match-final-score {
            font-size: 1.5rem;
            margin: 1rem 0;
            color: #ffffff;
        }
        
        .game-over-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }
        
        .game-over-buttons button {
            min-width: 150px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 0;
                margin: 0;
            }
            
            .mobile-controls {
                display: flex;
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 1000;
            }
            
            .instructions {
                display: none;
            }
            
            .game-container {
                padding: 1rem;
                width: 100%;
                height: 100vh;
                display: flex;
                flex-direction: column;
                justify-content: space-between;
            }
            
            h1 {
                font-size: 1.8rem;
                margin-bottom: 0.5rem;
            }
            
            .game-info {
                padding: 0 0.5rem;
                margin-bottom: 0.5rem;
            }
            
            .avatar-container {
                width: 50px;
                height: 50px;
            }
            
            .score {
                font-size: 1.5rem;
            }
            
            canvas {
                width: 100%;
                height: auto;
                max-height: 50vh;
            }
            
            .controls {
                flex-direction: row;
                gap: 0.5rem;
                margin-top: 0.5rem;
            }
            
            .controls button {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
            
            .match-status {
                margin: 0.5rem 0;
            }
            
            .match-text {
                font-size: 1rem;
            }
            
            .game-over-modal {
                width: 90%;
                max-width: 400px;
                padding: 1.5rem;
            }
            
            .game-over-modal h2 {
                font-size: 1.5rem;
            }
            
            .winner-avatar {
                width: 100px;
                height: 100px;
            }
            
            .match-final-score {
                font-size: 1.2rem;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }
            
            .score {
                font-size: 1.2rem;
            }
            
            .avatar-container {
                width: 40px;
                height: 40px;
            }
            
            .mobile-controls button {
                width: 70px;
                height: 70px;
                font-size: 1.5rem;
            }
            
            .controls button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            
            .match-text {
                font-size: 0.9rem;
            }
            
            .first-to {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>DUSA Pong</h1>
        <div class="difficulty-indicator">Difficulty: <span id="difficulty">1</span></div>
        
        <div class="game-info">
            <div class="player-info">
                <div class="avatar-container player-color">
                    <img id="playerAvatar" src="" alt="Player">
                </div>
                <div class="score player-score" id="playerScore">0</div>
                <div class="match-score">Games: <span id="playerGames">0</span></div>
            </div>
            
            <div class="match-status">
                <div class="match-text">Best of 3</div>
                <div class="first-to">First to 7</div>
            </div>
            
            <div class="ai-info">
                <div class="score ai-score" id="aiScore">0</div>
                <div class="match-score">Games: <span id="aiGames">0</span></div>
                <div class="avatar-container ai-color">
                    <img id="aiAvatar" src="../../shared/assets/avatars/green-dusa/green-dusa-1.png" alt="FakeDusa">
                </div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div class="controls">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn">Pause</button>
            <button id="soundBtn">Sound: ON</button>
        </div>
        
        <div class="instructions">Use W/S or Arrow Keys to move your mirror paddle • Ball changes color based on last hit</div>
        
        <div class="mobile-controls">
            <button id="upBtn">↑</button>
            <button id="downBtn">↓</button>
        </div>
        
        <!-- Score celebration popup -->
        <div class="score-celebration" id="scoreCelebration">
            <img id="celebrationAvatar" src="" alt="Celebration">
        </div>
        
        <!-- Game over modal -->
        <div class="game-over-modal" id="gameOverModal">
            <h2 id="gameOverTitle">Game Over!</h2>
            <div class="winner-avatar">
                <img id="winnerAvatar" src="" alt="Winner">
            </div>
            <div class="match-final-score" id="matchFinalScore"></div>
            <div class="game-over-buttons">
                <button id="playAgainBtn">Play Again</button>
                <button id="newMatchBtn">New Match</button>
            </div>
        </div>
    </div>
    
    <script src="../../shared/scripts/embed-wrapper.js"></script>
    <script>
        'use strict';
        
        // Game identifier for embedding
        window.DUSA_GAME_ID = 'dusa-pong';
        
        // Constants
        const PADDLE_HEIGHT = 80;
        const PADDLE_WIDTH = 15;
        const BALL_SIZE = 12;
        const PADDLE_SPEED = 6;
        const INITIAL_BALL_SPEED = 5.2; // Perfect balance between low and medium
        const MAX_BALL_SPEED = 10;
        const SPEED_INCREASE_INTERVAL = 6; // Increase speed every 6 hits
        const SPEED_INCREASE_AMOUNT = 0.15; // Smaller increments for smoother progression
        const DIFFICULTY_THRESHOLDS = [8, 16, 32, 64];
        
        // Avatar system
        const PLAYER_AVATARS = [
            '../../shared/assets/avatars/blue-dusa/R9Ic6wUZ01AFhvd6eHz3y_e0985cf7119141f3ac602fc1bb3fd792.png',
            '../../shared/assets/avatars/blue-dusa/61d1ce9f0018404786df67d4077b10ef.png',
            '../../shared/assets/avatars/blue-dusa/f4620d83a9c64c96ae42c837e05aee88.png',
            '../../shared/assets/avatars/blue-dusa/9283026c9a63406f8cc578dfdc754ed9.png',
            '../../shared/assets/avatars/blue-dusa/f42f5cf602d946069dab6d9413f8f064.png',
            '../../shared/assets/avatars/blue-dusa/48adb8190d52445fbce2830bf9ceb316.png',
            '../../shared/assets/avatars/blue-dusa/03ac9e3e9d094cf596d178ec94098b90.png'
        ];
        
        const AI_AVATARS = [
            '../../shared/assets/avatars/green-dusa/green-dusa-1.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-2.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-3.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-4.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-5.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-6.png',
            '../../shared/assets/avatars/green-dusa/green-dusa-7.png'
        ];
        
        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const playerScoreElement = document.getElementById('playerScore');
        const aiScoreElement = document.getElementById('aiScore');
        const playerGamesElement = document.getElementById('playerGames');
        const aiGamesElement = document.getElementById('aiGames');
        const difficultyElement = document.getElementById('difficulty');
        const playerAvatarElement = document.getElementById('playerAvatar');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const soundBtn = document.getElementById('soundBtn');
        
        // AI Dynamic Behavior System
        const AI_CONFIG = {
            baseSpeed: 2.8,
            maxSpeed: 4.2,
            baseError: 30,
            reactionDelay: 10,
            
            // Momentum system
            momentum: {
                confidence: 0.5, // 0-1 scale
                streakCount: 0,
                lastResults: [] // Track last 5 ball exchanges
            },
            
            // Fatigue system
            fatigue: {
                current: 0, // 0-100
                accumulation: 1.5, // Per hit in rally
                recovery: 0.5, // Per frame when ball going away
                threshold: 60 // When fatigue affects performance
            },
            
            // Pressure system
            pressure: {
                threshold: 5, // Points when pressure kicks in
                nervousness: 0 // 0-1 scale
            },
            
            // Physical limitations
            physics: {
                maxAcceleration: 0.3,
                currentVelocity: 0,
                inertia: 0.85 // How much velocity carries over
            }
        };
        
        // Game state
        const gameState = {
            player: {
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                score: 0,
                gamesWon: 0,
                avatarIndex: 0
            },
            ai: {
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                score: 0,
                gamesWon: 0,
                targetY: canvas.height / 2,
                avatarIndex: 0,
                reactionTimer: 0,
                state: AI_CONFIG,
                lastHitY: canvas.height / 2,
                rallyCount: 0
            },
            match: {
                inProgress: false,
                gameNumber: 1,
                maxGames: 3,
                scoreToWin: 7
            },
            ball: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                vx: INITIAL_BALL_SPEED,
                vy: 0,
                speed: INITIAL_BALL_SPEED,
                baseSpeed: INITIAL_BALL_SPEED,
                color: '#3B82F6', // Blue for player
                lastHit: 'player',
                trail: [],
                hitCount: 0
            },
            isRunning: false,
            isPaused: false,
            soundEnabled: true,
            difficulty: 1,
            animationId: null,
            particles: [],
            flameParticles: [],
            restartDelay: false
        };
        
        // Input handling
        const keys = {
            w: false,
            s: false,
            ArrowUp: false,
            ArrowDown: false
        };
        
        // Audio context
        let audioContext = null;
        
        // Initialize audio
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Audio context failed:', e);
                    gameState.soundEnabled = false;
                }
            }
        }
        
        // Play sound
        function playSound(frequency, duration, type = 'sine') {
            if (!gameState.soundEnabled || !audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.error('Sound playback failed:', e);
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, color, velocity) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.velocity = velocity;
                this.life = 1;
                this.decay = 0.02;
                this.size = Math.random() * 4 + 2;
            }
            
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.life -= this.decay;
                this.size *= 0.98;
            }
            
            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }
        
        // Flame particle for ball trail
        class FlameParticle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.life = 1;
                this.decay = 0.05;
                this.size = BALL_SIZE;
                this.offsetY = Math.random() * 2 - 1;
            }
            
            update() {
                this.life -= this.decay;
                this.size *= 0.95;
                this.y += this.offsetY;
            }
            
            draw() {
                if (this.life <= 0) return;
                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                
                // Create flame gradient
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, this.color);
                gradient.addColorStop(0.5, this.color + '88');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Create particles
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i;
                const velocity = {
                    x: Math.cos(angle) * (Math.random() * 3 + 1),
                    y: Math.sin(angle) * (Math.random() * 3 + 1)
                };
                gameState.particles.push(new Particle(x, y, color, velocity));
            }
            
            // Limit particles
            if (gameState.particles.length > 100) {
                gameState.particles = gameState.particles.slice(-100);
            }
        }
        
        // Show score celebration
        function showScoreCelebration(isPlayer) {
            // Add extra delay on mobile for better visibility
            setTimeout(() => {
                const celebration = document.getElementById('scoreCelebration');
                const celebrationAvatar = document.getElementById('celebrationAvatar');
                
                // Set the avatar based on current progression
                if (isPlayer) {
                    celebrationAvatar.src = PLAYER_AVATARS[gameState.player.avatarIndex];
                    celebration.className = 'score-celebration player-celebration';
                } else {
                    celebrationAvatar.src = AI_AVATARS[gameState.ai.avatarIndex];
                    celebration.className = 'score-celebration ai-celebration';
                }
                
                // Show the celebration
                celebration.style.display = 'block';
                
                // Hide after animation
                setTimeout(() => {
                    celebration.style.display = 'none';
                }, 1000);
            }, 100);
        }
        
        // Dynamic ball speed increase
        function increaseBallSpeed() {
            gameState.ball.hitCount++;
            
            if (gameState.ball.hitCount % SPEED_INCREASE_INTERVAL === 0) {
                gameState.ball.speed = Math.min(
                    gameState.ball.speed + SPEED_INCREASE_AMOUNT,
                    MAX_BALL_SPEED
                );
                
                // Update ball velocity with new speed while maintaining direction
                const currentSpeed = Math.sqrt(gameState.ball.vx * gameState.ball.vx + gameState.ball.vy * gameState.ball.vy);
                const speedRatio = gameState.ball.speed / currentSpeed;
                gameState.ball.vx *= speedRatio;
                gameState.ball.vy *= speedRatio;
                
                // Visual feedback for speed increase
                canvas.style.boxShadow = '0 0 30px rgba(255, 215, 0, 0.7)';
                setTimeout(() => {
                    canvas.style.boxShadow = '0 0 20px rgba(30, 58, 138, 0.3)';
                }, 300);
                
                playSound(1100, 0.1);
            }
        }
        
        // Update AI momentum/confidence
        function updateAIMomentum() {
            const aiState = gameState.ai.state;
            const results = aiState.momentum.lastResults;
            
            if (results.length >= 3) {
                const aiHits = results.filter(r => r === 'ai').length;
                const playerHits = results.filter(r => r === 'player').length;
                
                // Update confidence based on recent performance
                if (aiHits > playerHits) {
                    aiState.momentum.confidence = Math.min(1, aiState.momentum.confidence + 0.1);
                    aiState.momentum.streakCount = Math.max(0, aiState.momentum.streakCount + 1);
                } else {
                    aiState.momentum.confidence = Math.max(0.2, aiState.momentum.confidence - 0.15);
                    aiState.momentum.streakCount = Math.min(0, aiState.momentum.streakCount - 1);
                }
            }
        }
        
        // Update avatars
        function updatePlayerAvatar() {
            const avatarIndex = Math.min(Math.floor(gameState.player.score / 8), PLAYER_AVATARS.length - 1);
            if (avatarIndex !== gameState.player.avatarIndex) {
                gameState.player.avatarIndex = avatarIndex;
                playerAvatarElement.src = PLAYER_AVATARS[avatarIndex];
                
                // Celebration effect
                const avatarContainer = playerAvatarElement.parentElement;
                avatarContainer.style.animation = 'none';
                setTimeout(() => {
                    avatarContainer.style.animation = 'celebrate 0.5s ease';
                }, 10);
                
                playSound(1320, 0.3);
            }
        }
        
        function updateAIAvatar() {
            const avatarIndex = Math.min(Math.floor(gameState.ai.score / 8), AI_AVATARS.length - 1);
            if (avatarIndex !== gameState.ai.avatarIndex) {
                gameState.ai.avatarIndex = avatarIndex;
                document.getElementById('aiAvatar').src = AI_AVATARS[avatarIndex];
                
                // Celebration effect for AI
                const avatarContainer = document.getElementById('aiAvatar').parentElement;
                avatarContainer.style.animation = 'none';
                setTimeout(() => {
                    avatarContainer.style.animation = 'celebrate 0.5s ease';
                }, 10);
                
                playSound(880, 0.3);
            }
        }
        
        // Handle game win (first to 7)
        function handleGameWin(playerWon) {
            gameState.isRunning = false;
            
            if (playerWon) {
                gameState.player.gamesWon++;
                playerGamesElement.textContent = gameState.player.gamesWon;
                playSound(1320, 0.5);
                playSound(1568, 0.5);
                
                // Show big celebration
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => showScoreCelebration(true), i * 300);
                }
            } else {
                gameState.ai.gamesWon++;
                aiGamesElement.textContent = gameState.ai.gamesWon;
                playSound(440, 0.5, 'sawtooth');
            }
            
            // Show game over modal after a delay
            setTimeout(() => {
                const modal = document.getElementById('gameOverModal');
                const title = document.getElementById('gameOverTitle');
                const winnerAvatar = document.getElementById('winnerAvatar');
                const finalScore = document.getElementById('matchFinalScore');
                const playAgainBtn = document.getElementById('playAgainBtn');
                const newMatchBtn = document.getElementById('newMatchBtn');
                
                // Check if match is over (best of 3)
                const matchOver = gameState.player.gamesWon >= 2 || gameState.ai.gamesWon >= 2;
                
                if (matchOver) {
                    // Match complete
                    const winner = gameState.player.gamesWon >= 2 ? 'PLAYER' : 'FAKEDUSA';
                    title.textContent = `${winner} WINS THE MATCH!`;
                    title.style.color = winner === 'PLAYER' ? '#3B82F6' : '#4CAF50';
                    
                    // Set winner avatar
                    if (winner === 'PLAYER') {
                        winnerAvatar.src = PLAYER_AVATARS[gameState.player.avatarIndex];
                        winnerAvatar.parentElement.style.borderColor = '#3B82F6';
                        winnerAvatar.parentElement.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.8)';
                    } else {
                        winnerAvatar.src = AI_AVATARS[gameState.ai.avatarIndex];
                        winnerAvatar.parentElement.style.borderColor = '#4CAF50';
                        winnerAvatar.parentElement.style.boxShadow = '0 0 30px rgba(76, 175, 80, 0.8)';
                    }
                    
                    finalScore.textContent = `Final Score: Player ${gameState.player.gamesWon} - ${gameState.ai.gamesWon} FakeDusa`;
                    playAgainBtn.textContent = 'New Match';
                    playAgainBtn.style.display = 'inline-block';
                    newMatchBtn.style.display = 'none';
                    
                    playAgainBtn.onclick = () => {
                        modal.style.display = 'none';
                        gameState.match.inProgress = false;
                        startBtn.textContent = 'Start Game';
                        startGame();
                    };
                } else {
                    // Game complete, more games to play
                    title.textContent = playerWon ? 'You Won This Game!' : 'FakeDusa Won This Game!';
                    title.style.color = playerWon ? '#3B82F6' : '#4CAF50';
                    
                    // Set winner avatar for this game
                    if (playerWon) {
                        winnerAvatar.src = PLAYER_AVATARS[gameState.player.avatarIndex];
                        winnerAvatar.parentElement.style.borderColor = '#3B82F6';
                        winnerAvatar.parentElement.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.8)';
                    } else {
                        winnerAvatar.src = AI_AVATARS[gameState.ai.avatarIndex];
                        winnerAvatar.parentElement.style.borderColor = '#4CAF50';
                        winnerAvatar.parentElement.style.boxShadow = '0 0 30px rgba(76, 175, 80, 0.8)';
                    }
                    
                    finalScore.textContent = `Games: Player ${gameState.player.gamesWon} - ${gameState.ai.gamesWon} FakeDusa`;
                    playAgainBtn.textContent = 'Next Game';
                    playAgainBtn.style.display = 'inline-block';
                    newMatchBtn.style.display = 'none';
                    
                    gameState.match.gameNumber++;
                    
                    playAgainBtn.onclick = () => {
                        modal.style.display = 'none';
                        startGame();
                    };
                }
                
                // Show the modal
                modal.style.display = 'block';
            }, 1500);
        }
        
        // Initialize game
        function init() {
            // Set initial avatars
            playerAvatarElement.src = PLAYER_AVATARS[0];
            document.getElementById('aiAvatar').src = AI_AVATARS[0];
            
            // Input handlers
            document.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                    e.preventDefault();
                }
            });
            
            // Mobile controls
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');
            
            // Prevent default touch behaviors
            upBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowUp = true;
            });
            upBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowUp = false;
            });
            downBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.ArrowDown = true;
            });
            downBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys.ArrowDown = false;
            });
            
            // Touch swipe controls for canvas
            let touchStartY = null;
            canvas.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (touchStartY !== null) {
                    const touchY = e.touches[0].clientY;
                    const diff = touchStartY - touchY;
                    
                    // Move paddle based on swipe
                    if (Math.abs(diff) > 10) {
                        if (diff > 0) {
                            keys.ArrowUp = true;
                            keys.ArrowDown = false;
                        } else {
                            keys.ArrowDown = true;
                            keys.ArrowUp = false;
                        }
                    }
                }
            });
            
            canvas.addEventListener('touchend', () => {
                touchStartY = null;
                keys.ArrowUp = false;
                keys.ArrowDown = false;
            });
            
            // Button controls
            startBtn.addEventListener('click', startGame);
            pauseBtn.addEventListener('click', togglePause);
            soundBtn.addEventListener('click', toggleSound);
            
            // Draw initial state
            draw();
        }
        
        function startGame() {
            // Reset match if starting fresh
            if (!gameState.match.inProgress) {
                gameState.player.gamesWon = 0;
                gameState.ai.gamesWon = 0;
                gameState.match.gameNumber = 1;
                gameState.match.inProgress = true;
                playerGamesElement.textContent = '0';
                aiGamesElement.textContent = '0';
                startBtn.textContent = 'New Match';
            } else {
                startBtn.textContent = 'Restart Game';
            }
            
            // Reset game scores
            gameState.player.score = 0;
            gameState.ai.score = 0;
            gameState.player.avatarIndex = 0;
            gameState.ai.avatarIndex = 0;
            gameState.difficulty = 1;
            
            // Reset AI state
            gameState.ai.state.momentum.confidence = 0.5;
            gameState.ai.state.momentum.streakCount = 0;
            gameState.ai.state.momentum.lastResults = [];
            gameState.ai.state.fatigue.current = 0;
            gameState.ai.state.pressure.nervousness = 0;
            gameState.ai.state.physics.currentVelocity = 0;
            gameState.ai.rallyCount = 0;
            
            gameState.ball.speed = INITIAL_BALL_SPEED;
            gameState.ball.baseSpeed = INITIAL_BALL_SPEED;
            
            playerScoreElement.textContent = '0';
            aiScoreElement.textContent = '0';
            difficultyElement.textContent = '1';
            playerAvatarElement.src = PLAYER_AVATARS[0];
            document.getElementById('aiAvatar').src = AI_AVATARS[0];
            
            resetBall();
            gameState.isRunning = true;
            gameState.isPaused = false;
            
            initAudio();
            gameLoop();
        }
        
        function togglePause() {
            if (!gameState.isRunning) return;
            
            gameState.isPaused = !gameState.isPaused;
            pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
            
            if (!gameState.isPaused) {
                gameLoop();
            }
        }
        
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            soundBtn.textContent = `Sound: ${gameState.soundEnabled ? 'ON' : 'OFF'}`;
        }
        
        function resetBall() {
            gameState.ball.x = canvas.width / 2;
            gameState.ball.y = canvas.height / 2;
            // Start with slower speed after reset
            gameState.ball.speed = INITIAL_BALL_SPEED * 0.7; // 30% slower initial speed
            gameState.ball.vx = (Math.random() > 0.5 ? 1 : -1) * gameState.ball.speed;
            gameState.ball.vy = (Math.random() - 0.5) * gameState.ball.speed * 0.3;
            gameState.ball.trail = [];
            gameState.ball.hitCount = 0;
            gameState.flameParticles = [];
            
            // Reset rally count but maintain some AI state for continuity
            gameState.ai.rallyCount = 0;
            gameState.ai.reactionTimer = 0;
            gameState.ai.targetY = canvas.height / 2;
            
            // Fatigue recovery between points
            gameState.ai.state.fatigue.current *= 0.7; // Partial recovery
            
            // Add a brief pause on reset
            gameState.restartDelay = true;
            setTimeout(() => {
                gameState.restartDelay = false;
            }, 800);
        }
        
        function updateDifficulty() {
            const totalScore = gameState.player.score + gameState.ai.score;
            let newDifficulty = 1;
            
            for (let i = DIFFICULTY_THRESHOLDS.length - 1; i >= 0; i--) {
                if (totalScore >= DIFFICULTY_THRESHOLDS[i]) {
                    newDifficulty = i + 2;
                    break;
                }
            }
            
            if (newDifficulty !== gameState.difficulty) {
                gameState.difficulty = newDifficulty;
                difficultyElement.textContent = newDifficulty;
                
                // Increase base ball speed for difficulty
                gameState.ball.baseSpeed = INITIAL_BALL_SPEED + (newDifficulty - 1) * 0.4;
                gameState.ball.baseSpeed = Math.min(gameState.ball.baseSpeed, MAX_BALL_SPEED - 1);
                
                // Visual feedback
                canvas.style.boxShadow = `0 0 ${20 + newDifficulty * 5}px rgba(255, 215, 0, 0.5)`;
                setTimeout(() => {
                    canvas.style.boxShadow = '0 0 20px rgba(30, 58, 138, 0.3)';
                }, 500);
                
                playSound(880, 0.2);
            }
        }
        
        function update() {
            if (!gameState.isRunning || gameState.isPaused || gameState.restartDelay) return;
            
            // Update player paddle
            if (keys.w || keys.ArrowUp) {
                gameState.player.y = Math.max(0, gameState.player.y - PADDLE_SPEED);
            }
            if (keys.s || keys.ArrowDown) {
                gameState.player.y = Math.min(canvas.height - PADDLE_HEIGHT, gameState.player.y + PADDLE_SPEED);
            }
            
            // Update AI with natural behavior system
            const aiState = gameState.ai.state;
            
            // Update fatigue
            if (gameState.ball.vx > 0) {
                aiState.fatigue.current = Math.min(100, aiState.fatigue.current + aiState.fatigue.accumulation);
                gameState.ai.reactionTimer++;
            } else {
                aiState.fatigue.current = Math.max(0, aiState.fatigue.current - aiState.fatigue.recovery);
                gameState.ai.reactionTimer = 0;
            }
            
            // Update pressure based on game state
            if (gameState.player.score >= aiState.pressure.threshold || 
                gameState.ai.score >= aiState.pressure.threshold) {
                const scoreDiff = Math.abs(gameState.player.score - gameState.ai.score);
                aiState.pressure.nervousness = Math.min(1, scoreDiff * 0.15);
            }
            
            // Calculate effective AI parameters
            const fatigueMultiplier = aiState.fatigue.current > aiState.fatigue.threshold ? 0.8 : 1;
            const pressureMultiplier = 1 - (aiState.pressure.nervousness * 0.3);
            const confidenceMultiplier = 0.8 + (aiState.momentum.confidence * 0.4);
            
            const effectiveSpeed = aiState.baseSpeed * fatigueMultiplier * confidenceMultiplier;
            const effectiveError = aiState.baseError * (1 + aiState.pressure.nervousness) / confidenceMultiplier;
            const effectiveDelay = aiState.reactionDelay + (aiState.fatigue.current > 80 ? 5 : 0);
            
            // AI targeting with natural imperfection
            if (gameState.ball.vx > 0 && 
                gameState.ball.x > canvas.width / 3 && 
                gameState.ai.reactionTimer > effectiveDelay) {
                
                // Add momentum-based prediction error
                const predictionError = (Math.random() - 0.5) * effectiveError;
                const momentumError = (1 - aiState.momentum.confidence) * 20;
                
                // Sometimes overshoot or undershoot
                const overshoot = Math.random() < 0.2 ? (Math.random() - 0.5) * 30 : 0;
                
                gameState.ai.targetY = gameState.ball.y - PADDLE_HEIGHT / 2 + predictionError + momentumError + overshoot;
                
                // Physical limitation: can't instantly know exact position
                if (Math.random() < aiState.pressure.nervousness * 0.3) {
                    gameState.ai.targetY += (Math.random() - 0.5) * 50; // Nervous twitch
                }
            }
            
            // Apply physics-based movement
            const targetDiff = gameState.ai.targetY - gameState.ai.y;
            const desiredVelocity = Math.sign(targetDiff) * Math.min(Math.abs(targetDiff), effectiveSpeed);
            
            // Apply acceleration limits and inertia
            const velocityDiff = desiredVelocity - aiState.physics.currentVelocity;
            const acceleration = Math.sign(velocityDiff) * Math.min(Math.abs(velocityDiff), aiState.physics.maxAcceleration);
            
            aiState.physics.currentVelocity = aiState.physics.currentVelocity * aiState.physics.inertia + acceleration;
            gameState.ai.y += aiState.physics.currentVelocity;
            
            // Add slight shake when fatigued or nervous
            if (aiState.fatigue.current > 80 || aiState.pressure.nervousness > 0.5) {
                gameState.ai.y += (Math.random() - 0.5) * 2;
            }
            
            gameState.ai.y = Math.max(0, Math.min(canvas.height - PADDLE_HEIGHT, gameState.ai.y));
            
            // Update ball
            gameState.ball.x += gameState.ball.vx;
            gameState.ball.y += gameState.ball.vy;
            
            // Create flame trail
            gameState.flameParticles.push(new FlameParticle(gameState.ball.x, gameState.ball.y, gameState.ball.color));
            if (gameState.flameParticles.length > 20) {
                gameState.flameParticles.shift();
            }
            
            // Ball collision with top/bottom
            if (gameState.ball.y - BALL_SIZE / 2 <= 0 || gameState.ball.y + BALL_SIZE / 2 >= canvas.height) {
                gameState.ball.vy = -gameState.ball.vy;
                playSound(220, 0.1);
                createParticles(gameState.ball.x, gameState.ball.y, gameState.ball.color, 5);
            }
            
            // Ball collision with paddles
            // Player paddle (left)
            if (gameState.ball.x - BALL_SIZE / 2 <= PADDLE_WIDTH &&
                gameState.ball.y >= gameState.player.y &&
                gameState.ball.y <= gameState.player.y + PADDLE_HEIGHT &&
                gameState.ball.vx < 0) {
                
                gameState.ball.vx = Math.abs(gameState.ball.vx);
                gameState.ball.color = '#3B82F6'; // Blue
                gameState.ball.lastHit = 'player';
                
                // Add spin based on paddle hit position
                const relativeIntersectY = (gameState.player.y + PADDLE_HEIGHT / 2) - gameState.ball.y;
                const normalizedRelativeIntersectionY = relativeIntersectY / (PADDLE_HEIGHT / 2);
                gameState.ball.vy = -normalizedRelativeIntersectionY * gameState.ball.speed * 0.75;
                
                // Increase ball speed dynamically
                increaseBallSpeed();
                gameState.ai.rallyCount++;
                
                // Update AI momentum based on player hit
                gameState.ai.state.momentum.lastResults.push('player');
                if (gameState.ai.state.momentum.lastResults.length > 5) {
                    gameState.ai.state.momentum.lastResults.shift();
                }
                updateAIMomentum();
                
                playSound(440, 0.1);
                createParticles(PADDLE_WIDTH, gameState.ball.y, '#3B82F6', 10);
                
                // Mirror shine effect
                const paddleGlow = document.querySelector('.player-info .avatar-container');
                paddleGlow.style.boxShadow = '0 0 40px rgba(59, 130, 246, 1)';
                setTimeout(() => {
                    paddleGlow.style.boxShadow = '0 0 20px rgba(59, 130, 246, 0.8)';
                }, 200);
            }
            
            // AI paddle (right)
            if (gameState.ball.x + BALL_SIZE / 2 >= canvas.width - PADDLE_WIDTH &&
                gameState.ball.y >= gameState.ai.y &&
                gameState.ball.y <= gameState.ai.y + PADDLE_HEIGHT &&
                gameState.ball.vx > 0) {
                
                gameState.ball.vx = -Math.abs(gameState.ball.vx);
                gameState.ball.color = '#4CAF50'; // Green
                gameState.ball.lastHit = 'ai';
                
                // Add spin
                const relativeIntersectY = (gameState.ai.y + PADDLE_HEIGHT / 2) - gameState.ball.y;
                const normalizedRelativeIntersectionY = relativeIntersectY / (PADDLE_HEIGHT / 2);
                gameState.ball.vy = -normalizedRelativeIntersectionY * gameState.ball.speed * 0.75;
                
                // Increase ball speed dynamically
                increaseBallSpeed();
                gameState.ai.rallyCount++;
                
                // Update AI momentum based on AI hit
                gameState.ai.state.momentum.lastResults.push('ai');
                if (gameState.ai.state.momentum.lastResults.length > 5) {
                    gameState.ai.state.momentum.lastResults.shift();
                }
                updateAIMomentum();
                
                playSound(330, 0.1);
                createParticles(canvas.width - PADDLE_WIDTH, gameState.ball.y, '#4CAF50', 10);
                
                // Snake glow effect
                const aiGlow = document.querySelector('.ai-info .avatar-container');
                aiGlow.style.boxShadow = '0 0 40px rgba(76, 175, 80, 1)';
                setTimeout(() => {
                    aiGlow.style.boxShadow = '0 0 20px rgba(76, 175, 80, 0.8)';
                }, 200);
            }
            
            // Score points
            if (gameState.ball.x < 0) {
                // FakeDusa scores
                gameState.ai.score++;
                aiScoreElement.textContent = gameState.ai.score;
                updateAIAvatar();
                
                // Update FakeDusa confidence after scoring
                gameState.ai.state.momentum.confidence = Math.min(1, gameState.ai.state.momentum.confidence + 0.2);
                
                // Show FakeDusa celebration
                showScoreCelebration(false);
                
                playSound(220, 0.3, 'sawtooth');
                createParticles(0, gameState.ball.y, '#FF6347', 20);
                
                // Check if FakeDusa won the game
                if (gameState.ai.score >= gameState.match.scoreToWin) {
                    handleGameWin(false);
                } else {
                    updateDifficulty();
                    resetBall();
                }
                
                // Update embed score
                if (window.DUSAEmbed) {
                    window.DUSAEmbed.updateScore(gameState.player.score);
                }
            }
            
            if (gameState.ball.x > canvas.width) {
                // Player scores
                gameState.player.score++;
                playerScoreElement.textContent = gameState.player.score;
                updatePlayerAvatar();
                
                // Update AI confidence after being scored on
                gameState.ai.state.momentum.confidence = Math.max(0.2, gameState.ai.state.momentum.confidence - 0.25);
                
                // Show player celebration
                showScoreCelebration(true);
                
                playSound(880, 0.2);
                playSound(1100, 0.2);
                createParticles(canvas.width, gameState.ball.y, '#FFD700', 20);
                
                // Check if player won the game
                if (gameState.player.score >= gameState.match.scoreToWin) {
                    handleGameWin(true);
                } else {
                    updateDifficulty();
                    resetBall();
                }
                
                // Update embed score
                if (window.DUSAEmbed) {
                    window.DUSAEmbed.updateScore(gameState.player.score);
                }
            }
            
            // Update particles
            gameState.particles = gameState.particles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });
            
            // Update flame particles
            gameState.flameParticles = gameState.flameParticles.filter(particle => {
                particle.update();
                return particle.life > 0;
            });
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0D1117';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw center line
            ctx.strokeStyle = '#1E3A8A44';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw flame particles
            gameState.flameParticles.forEach(particle => particle.draw());
            
            // Draw particles
            gameState.particles.forEach(particle => particle.draw());
            
            // Draw player paddle (mirror effect)
            const gradient = ctx.createLinearGradient(0, gameState.player.y, PADDLE_WIDTH, gameState.player.y);
            gradient.addColorStop(0, '#3B82F6');
            gradient.addColorStop(0.5, '#60A5FA');
            gradient.addColorStop(1, '#3B82F6');
            
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#3B82F6';
            ctx.fillRect(0, gameState.player.y, PADDLE_WIDTH, PADDLE_HEIGHT);
            
            // Mirror shine effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(PADDLE_WIDTH / 3, gameState.player.y + 10, 2, PADDLE_HEIGHT - 20);
            
            // Draw AI paddle (snake theme)
            ctx.fillStyle = '#4CAF50';
            ctx.shadowColor = '#4CAF50';
            ctx.fillRect(canvas.width - PADDLE_WIDTH, gameState.ai.y, PADDLE_WIDTH, PADDLE_HEIGHT);
            
            // Snake pattern
            ctx.fillStyle = '#388E3C';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(
                    canvas.width - PADDLE_WIDTH + 2,
                    gameState.ai.y + i * 25 + 10,
                    PADDLE_WIDTH - 4,
                    10
                );
            }
            
            ctx.shadowBlur = 0;
            
            // Draw ball (flame ball)
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = gameState.ball.color;
            
            const ballGradient = ctx.createRadialGradient(
                gameState.ball.x, gameState.ball.y, 0,
                gameState.ball.x, gameState.ball.y, BALL_SIZE
            );
            ballGradient.addColorStop(0, '#FFFFFF');
            ballGradient.addColorStop(0.3, gameState.ball.color);
            ballGradient.addColorStop(1, gameState.ball.color + '88');
            
            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(gameState.ball.x, gameState.ball.y, BALL_SIZE, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        function gameLoop() {
            update();
            draw();
            
            if (gameState.isRunning && !gameState.isPaused) {
                gameState.animationId = requestAnimationFrame(gameLoop);
            }
        }
        
        // Canvas resize handler for mobile
        function resizeCanvas() {
            if (window.innerWidth <= 768) {
                const container = document.querySelector('.game-container');
                const maxWidth = container.clientWidth - 32; // Account for padding
                const aspectRatio = 800 / 400;
                
                // Calculate dimensions
                let newWidth = Math.min(maxWidth, 800);
                let newHeight = newWidth / aspectRatio;
                
                // Ensure it fits in viewport
                const maxHeight = window.innerHeight * 0.5;
                if (newHeight > maxHeight) {
                    newHeight = maxHeight;
                    newWidth = newHeight * aspectRatio;
                }
                
                // Apply styles without changing internal canvas dimensions
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
            } else {
                canvas.style.width = '';
                canvas.style.height = '';
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        
        // Initialize the game
        init();
        resizeCanvas();
        
        // Add celebration keyframe
        const style = document.createElement('style');
        style.textContent = `
            @keyframes celebrate {
                0%, 100% { transform: scale(1) rotate(0deg); }
                25% { transform: scale(1.2) rotate(-10deg); }
                75% { transform: scale(1.2) rotate(10deg); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>